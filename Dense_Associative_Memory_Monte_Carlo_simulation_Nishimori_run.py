import numpy as np
import jax
import matplotlib.pyplot as plt
jax.config.update("jax_enable_x64", True)

from Dense_Associative_Memory_Monte_Carlo_simulation import *

def nishimori_run(p, seed, N, L, t, init_phase = None):
    '''
    Run Monte-Carlo simulations on the Nishimori line for a predefined range of T and alpha to reproduce Fig. (4).
    The results are saved in .npy files.
    
    Inputs
    ------
    p (int):
        Interaction order of the teacher and student networks.
    seed (int):
        User-defined seed for random number generation.
    N (int):
        Number of entries in the patterns memorized by the student network and generated by the teacher network.
    L (int):
        Number of patterns sampled from the student network.
    t (int):
        Number of Monte-Carlo steps for the teacher and student networks.
    init_phase (str):
        For the global retrieval phase, type "global".
        For the local retrieval phase, type "local".
        To initialize the student pattern equal to the teacher pattern, type anything else.
    
    Outputs
    -------
    None
    '''
    n_beta = 20
    n_alpha = 3
    
    T_range = np.linspace(1, 3, num = n_beta, endpoint = True)
    alpha_range = np.array([3, 6, 9])
    
    M = int(np.max(alpha_range) * N**(p-1)/np.math.factorial(p))
    
    key = jax.random.PRNGKey(seed)
    key_teacher, key_student = jax.random.split(key)
    
    mean_xi_overlaps = np.zeros((n_beta, n_alpha))
    std_xi_overlaps = np.zeros((n_beta, n_alpha))
    
    if init_phase == "global":
        init_phase = "_global"
        with open("./Data/overlaps/inverse_global_overlap_p=%d.npy" % p, "rb") as file:
            student_init_overlap = np.load(file)[: : 21]
    
    elif init_phase == "local":
        init_phase = "_local"
        with open("./Data/overlaps/inverse_local_overlap_p=%d.npy" % p, "rb") as file:
            student_init_overlap = np.load(file)[: : 21]

    else:
        init_phase = ""
        student_init_overlap = 1
        
    teacher_batch_size = int(np.sqrt(N))
    student_batch_size = int(np.sqrt(N))
    
    teacher = Model("gardner", p, N, 1, M, teacher_batch_size, key_teacher)
    student = Model("gardner", p, N, M, L, student_batch_size, key_student)
    
    xi_s_spins = None
    for i, T in enumerate(T_range):
        if T == 0:
            beta = np.inf
        else:
            beta = 1/T
        
        if T < 1.5:
            teacher_init_overlap = 1
        else:
            teacher_init_overlap = 0
        
        xi_s_spins, sigma_spins = teacher.init_spins(teacher_init_overlap, ori_spins = xi_s_spins)
        
        sigma_spins = teacher.generate_spins(t, beta, xi_s_spins, sigma_spins)
        # print("Teacher done")
        
        for j, alpha in enumerate(alpha_range):
            if T == 0:
                beta = np.inf
            else:
                beta = 1/T
            
            M = int(alpha * N**(p-1)/np.math.factorial(p))
            
            xi_s_spins, xi_spins = student.init_spins(student_init_overlap[i, j], ori_spins = xi_s_spins)
            
            xi_spins = student.generate_spins(t, beta, sigma_spins.T[: M], xi_spins)
            # print("Student done")
            xi_overlaps = (xi_s_spins @ xi_spins)/N
            mean_xi_overlaps[i, j] = np.mean(xi_overlaps)
            std_xi_overlaps[i, j] = np.std(xi_overlaps)
    
    with open("./Data/overlaps/mean%s_xi_overlap_p=%d.npy" % (init_phase, p), "wb") as file:
        np.save(file, mean_xi_overlaps)
    
    with open("./Data/overlaps/std%s_xi_overlap_p=%d.npy" % (init_phase, p), "wb") as file:
        np.save(file, std_xi_overlaps)